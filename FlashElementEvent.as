package {	// Flash imports	import flash.events.Event;	import flash.external.ExternalInterface;	import flash.utils.describeType;	public final class FlashElementEvent extends Event {		/**			The constructor is useless because there is only the static method dispatch which is useful			@constructor			@ignore		*/		public function FlashElementEvent(type:String) {			super(type); // Useless but who knows…		} // end of constructor		/**			Dispatch an event to the DOM			@static @function			@param {Event|String} event The event to dispatch.		*/		public static function dispatch(event:*):void {			// Only the event type was provided, we have to create a new Event			if (typeof event === "string") {				event = new Event(event);			}			// Fix the event by removing useless (for the DOM) properties			event = fixEvent(event);			// Dispatch the event in the DOM!			ExternalInterface.call('FlashElement.instances["' + ExternalInterface.objectID + '"].exposeEvent', event);		} // end of dispatch()		/**			Fix an event to prepare it for being dispatched to the DOM			@private @static @function			@param {Event} e The event to fix			@returns {Object} A fixed dummy object		*/		private static function fixEvent(e:*):Object {			var				// Prepare a copy of the event (to remove unwanted properties)				event:Object = {},				// The event's property to ignore (irrelevent in the DOM)				ignore:Array = "bubbles cancelable eventPhase target currentTarget localX localY isRelatedObjectInaccessible relatedObject".split(" "),				// Loop specific vars				accessor:XML, property:String, value:*;			// Loop through each Event's properties			for each (accessor in describeType(e)..accessor.@name) {				property = accessor.toString();				value    = e[property];				// Some properties have to be ignored				if (ignore.indexOf(property) !== -1) {					continue;				}				// The stage doesn't have any sense on a page, remove it and create clientX & clientY				if (property === "stageX" || property === "stageY") {					property = property.replace(/stage/, 'client');					value = Math.round(value); // Seriously, why is there floatting values?				}				// Rename the buttonDown property				if (property === "buttonDown") {					property = "button";					value = 0; // FIXME: This value doesn't reflect real button's DOM Event property				}				// Rename the delta property for deltaY				if (property === "delta") {					property = "deltaY";				}				// Copy the property				event[property] = value;			}			return event;		} // end of fixEvent()	} // end of class} // end of package